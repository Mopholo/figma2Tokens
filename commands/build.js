import Conf from "conf"
import Glob from "glob"
import fs from 'fs';
import path from 'path'
import { fileURLToPath } from 'url';
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);


let defaultComment = "Don't modify auto-generated by figma2Tokens"

const commentOpen = "/*";
const commentClose = "*/";
const cssSep = " : ";
const nl = "\n"
const tab = "\t"
const fileRepl = "$file$";
const embedBlockSeperator = "/\\"

const schema = {
    Glob: {
        type: 'string',
        default: '**/*.json'
    },
    In: {
        type: 'string',
        default: "/src/tokens/"
    },
    Out: {
        type: 'string',
        default: '/src/static/css/generated/'
    },
    Block: {
        type: 'array',
        default: [":root[data-theme='$file$'] {", "}"]
    },
    Ext: {
        type: 'string',
        default: 'css'
    },
    Mark: {
        type: 'string',
        default: defaultComment
    },
    Pfx: {
        type: 'string',
        default: "--"
    },
    Sep: {
        type: 'string',
        default: '-'
    },
    Ref: {
        type: 'array',
        default: ["var(", ")"]
    }
};

let defaults = {
    Cfg: "figma2Tokens.cfg",
    Glob: '**/*.json',
    Dry: false,
    In: "/src/tokens/",
    Out: "/src/static/css/generated/",
    Mark: defaultComment,
    Block: [":root[data-theme='$file$'] {", "}"],
    Ext: "css",
    Pfx: "--",
    Sep: "-",
    Ref: ["var(", ")"],
}

function buildDirs (dir) {
    if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
    }
}

function mergeOptions (opts) {

    // Default structure
    let switches = Object.assign({}, defaults);
    let conf = new Conf({ schema, configName: opts?.Cfg ? opts.Cfg : switches.Cfg, cwd: "./" });

    // Assign cfg file choices - overwrites default 
    switches = Object.assign(switches, conf.store);

    // Merge command line options - overwrites cfg 
    switches = Object.assign(switches, opts)


    // patch input/output directories 
    switches.In = '.' + switches.In;
    switches.Out = '.' + switches.Out;

    // Computed 
    switches.search = switches.In + switches.Glob;

    // Make sure directories exist 
    buildDirs(switches.In);
    buildDirs(switches.Out);

    return switches;
}



function extractEmbedSwitches (treeTokens) {
    let rawSwitches = {};
    let embedSwitches = {};

    if (!treeTokens["figma2Tokens"])
        return rawSwitches;

    rawSwitches = treeTokens["figma2Tokens"];

    for (let key in rawSwitches) {
        let contents = rawSwitches[key];

        if (contents?.value)
            embedSwitches[key] = contents.value;
    }

    if (embedSwitches?.block) {
        embedSwitches.block = embedSwitches.block.split(embedBlockSeperator);
        if (embedSwitches.block.length != 2) {
            console.warn("Embedded 'block' should be an array seperated by " + embedBlockSeperator);
            console.warn(embedSwitches.block);
            embedSwitches.block = undefined;
        }
    }

    delete treeTokens["figma2Tokens"];

    return embedSwitches;
}

function flattenTokens (treeTokens, processSwitches) {
    const flatTokens = {};

    recursiveFlatten(treeTokens, '');

    return flatTokens;

    function recursiveFlatten (currentObject, previousKeyName) {

        for (let key in currentObject) {
            let contents = currentObject[key];

            if (contents.constructor !== Object || contents?.value) {
                if (contents?.value[0] === "{") {
                    contents.value = processSwitches.Ref[0] + processSwitches.Pfx + contents.value.substring(1, contents.value.length - 1) + processSwitches.Ref[1];
                }
                flatTokens[processSwitches.Pfx + (previousKeyName ? previousKeyName + processSwitches.Sep : "") + key] = contents.value;
            } else {
                recursiveFlatten(contents, (previousKeyName ? previousKeyName + processSwitches.Sep : "") + key);
            }
        }
    }
}

function getTokens (treeTokens, processSwitches) {
    let flatTokens;
    let tokenCount = 0;

    flatTokens = flattenTokens(treeTokens, processSwitches);
    tokenCount = Object.keys(flatTokens).length;

    if (tokenCount <= 0) {
        flatTokens = null;
    }

    return [flatTokens, tokenCount]
}



function createBlock (tokens, outName, comment, block) {

    let data = "";

    if (comment)
        data += commentOpen + comment + commentClose + nl;

    if (block) {
        if (block[0].indexOf(fileRepl) > 0) {
            block[0] = block[0].replace(fileRepl, outName)
        }
        data += block[0] + nl;
    }

    for (let key in tokens) {
        let value = tokens[key];
        data += (tab + key + cssSep + value + nl);
    }

    if (block)
        data += block[1];

    data += nl;

    return data;
}



function createTokensObject (data) {
    let treeTokens;
    let embedSwitches;

    try {
        treeTokens = JSON.parse(data)
        embedSwitches = extractEmbedSwitches(treeTokens);

    } catch (err) {
        return [null, null, 0]
    }

    return [treeTokens, embedSwitches, Object.keys(treeTokens).length];
}

function getOutfile (fileName, switches, embedSwitches) {
    let outFile;
    let ext = (embedSwitches && embedSwitches?.ext) ? embedSwitches.ext : switches.Ext;
    let outName = (embedSwitches && embedSwitches?.file) ? embedSwitches.file : fileName;

    outFile = switches.Out + outName + "." + ext;

    return [outFile, outName];
}

function getComment (switches, embedSwitches) {
    let comment;

    if (embedSwitches && embedSwitches?.mark) {
        comment = embedSwitches.mark;
    } else
        comment = switches.Mark;

    return comment;
}

function getBlock (switches, embedSwitches) {
    let block;

    if (embedSwitches && embedSwitches?.block) {
        block = embedSwitches.block;
    } else
        block = switches.Block;

    return block;
}

function build (opts) {

    let switches = mergeOptions(opts);

    let glob = new Glob(switches.search, {}, function (err, files) {
        let block;

        if (err) {
            console.log("Glob " + switches.Glob + " had a search error " + err)
        } else if (files.length) {

            if (switches.Dry) console.log("Dry run found " + files.length + " files using glob " + switches.search);

            files.forEach(function (file) {

                let parsed = path.parse(file)

                fs.readFile(file, function (err, data) {
                    if (err) {
                        console.log("Could not open token file! " + err);
                    } else {

                        const [treeTokens, embedSwitches, rawCount] = createTokensObject(data);

                        if (!switches.Dry) {

                            const [tokens, tokenCount] = getTokens(treeTokens, switches);

                            if (tokens) {
                                const [outFile, outName] = getOutfile(parsed.name, switches, embedSwitches);
                                let comment = getComment(switches, embedSwitches);
                                let block = getBlock(switches, embedSwitches);


                                block = createBlock(tokens, outName, comment, block);

                                fs.writeFile(outFile, block, null, function (err) {
                                    if (!err) {

                                        console.log(file + " transformed " + tokenCount + " tokens into " + outFile);
                                        if (switches.Zed)
                                            console.log("\n" + outFile + " --> " + block);
                                    } else if (err) {
                                        console.log("Error writing " + outFile);
                                    }

                                });
                            } else {
                                console.warn(file + " token input was empty or invalid ");
                            }
                        }
                        else {
                            console.log("    " + file);
                        }
                    }
                });


            })
        } else {
            console.warn("No token files found using glob " + switches.search);
        }
    })
}

export { build }; 